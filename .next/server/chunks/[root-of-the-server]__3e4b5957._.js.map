{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 6, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"","debugId":null}},
    {"offset": {"line": 68, "column": 0}, "map": {"version":3,"sources":["file:///project/sandbox/user-workspace/src/app/api/vendors/register/route.ts"],"sourcesContent":["import { NextResponse } from \"next/server\";\nimport bcrypt from \"bcryptjs\";\n\n// In-memory storage for demo - replace with database in production\nlet vendors: any[] = [];\n\nexport async function POST(request: Request) {\n  try {\n    const {\n      name,\n      email,\n      password,\n      businessName,\n      businessDescription,\n      phone,\n      location,\n      businessType,\n      serviceCategories\n    } = await request.json();\n\n    // Basic validation\n    if (!email || !password || !businessName) {\n      return NextResponse.json(\n        { error: \"Missing required fields\" },\n        { status: 400 }\n      );\n    }\n\n    // Check if email already exists\n    const existingVendor = vendors.find(v => v.email === email);\n    if (existingVendor) {\n      return NextResponse.json(\n        { error: \"Email already registered\" },\n        { status: 409 }\n      );\n    }\n\n    // Hash the password before storing\n    const hashedPassword = await bcrypt.hash(password, 10);\n\n    const newVendor = {\n      id: Date.now().toString(),\n      name,\n      email,\n      password: hashedPassword, // Store hashed password\n      businessName,\n      businessDescription,\n      phone,\n      location,\n      businessType,\n      serviceCategories,\n      verified: false,\n      createdAt: new Date().toISOString(),\n      updatedAt: new Date().toISOString()\n    };\n\n    vendors.push(newVendor);\n    \n    return NextResponse.json({\n      success: true,\n      vendor: {\n        id: newVendor.id,\n        name: newVendor.name,\n        email: newVendor.email,\n        businessName: newVendor.businessName,\n        verified: newVendor.verified\n      }\n    });\n  } catch (error) {\n    return NextResponse.json(\n      { error: \"Internal server error\" },\n      { status: 500 }\n    );\n  }\n}\n\n// GET endpoint to fetch all vendors (for admin purposes)\nexport async function GET() {\n  return NextResponse.json({ vendors });\n}\n"],"names":[],"mappings":";;;;AAAA;AACA;;;AAEA,mEAAmE;AACnE,IAAI,UAAiB,EAAE;AAEhB,eAAe,KAAK,OAAgB;IACzC,IAAI;QACF,MAAM,EACJ,IAAI,EACJ,KAAK,EACL,QAAQ,EACR,YAAY,EACZ,mBAAmB,EACnB,KAAK,EACL,QAAQ,EACR,YAAY,EACZ,iBAAiB,EAClB,GAAG,MAAM,QAAQ,IAAI;QAEtB,mBAAmB;QACnB,IAAI,CAAC,SAAS,CAAC,YAAY,CAAC,cAAc;YACxC,OAAO,gIAAA,CAAA,eAAY,CAAC,IAAI,CACtB;gBAAE,OAAO;YAA0B,GACnC;gBAAE,QAAQ;YAAI;QAElB;QAEA,gCAAgC;QAChC,MAAM,iBAAiB,QAAQ,IAAI,CAAC,CAAA,IAAK,EAAE,KAAK,KAAK;QACrD,IAAI,gBAAgB;YAClB,OAAO,gIAAA,CAAA,eAAY,CAAC,IAAI,CACtB;gBAAE,OAAO;YAA2B,GACpC;gBAAE,QAAQ;YAAI;QAElB;QAEA,mCAAmC;QACnC,MAAM,iBAAiB,MAAM,mIAAA,CAAA,UAAM,CAAC,IAAI,CAAC,UAAU;QAEnD,MAAM,YAAY;YAChB,IAAI,KAAK,GAAG,GAAG,QAAQ;YACvB;YACA;YACA,UAAU;YACV;YACA;YACA;YACA;YACA;YACA;YACA,UAAU;YACV,WAAW,IAAI,OAAO,WAAW;YACjC,WAAW,IAAI,OAAO,WAAW;QACnC;QAEA,QAAQ,IAAI,CAAC;QAEb,OAAO,gIAAA,CAAA,eAAY,CAAC,IAAI,CAAC;YACvB,SAAS;YACT,QAAQ;gBACN,IAAI,UAAU,EAAE;gBAChB,MAAM,UAAU,IAAI;gBACpB,OAAO,UAAU,KAAK;gBACtB,cAAc,UAAU,YAAY;gBACpC,UAAU,UAAU,QAAQ;YAC9B;QACF;IACF,EAAE,OAAO,OAAO;QACd,OAAO,gIAAA,CAAA,eAAY,CAAC,IAAI,CACtB;YAAE,OAAO;QAAwB,GACjC;YAAE,QAAQ;QAAI;IAElB;AACF;AAGO,eAAe;IACpB,OAAO,gIAAA,CAAA,eAAY,CAAC,IAAI,CAAC;QAAE;IAAQ;AACrC","debugId":null}}]
}