{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 3, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"","debugId":null}},
    {"offset": {"line": 61, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/aviji/OneDrive/Documents/marketplace/codeX/src/app/api/vendors/login/route.ts"],"sourcesContent":["import { NextRequest, NextResponse } from \"next/server\";\r\nimport bcrypt from \"bcryptjs\";\r\nimport { z } from \"zod\";\r\n\r\n// Input validation schema\r\nconst loginSchema = z.object({\r\n  email: z.string().email(),\r\n  password: z.string().min(6),\r\n});\r\n\r\nexport async function POST(request: NextRequest) {\r\n  try {\r\n    const body = await request.json();\r\n    const { email, password } = loginSchema.parse(body);\r\n\r\n    // In a real app, this would query your database\r\n    // For now, we'll use a mock implementation\r\n    const mockVendor = {\r\n      id: \"vendor_123\",\r\n      email: \"demo@travelmarket.com\",\r\n      password: \"$2a$10$92IXUNpkjO0rOQ5byMi.Ye4oKoEa3Ro9llC/.og/at2.uheWG/igi\", // bcrypt hash for \"password\"\r\n      name: \"Demo Vendor\",\r\n    };\r\n\r\n    // Check if email exists\r\n    if (email !== mockVendor.email) {\r\n      return NextResponse.json(\r\n        { error: \"Invalid email or password\" },\r\n        { status: 401 }\r\n      );\r\n    }\r\n\r\n    // Verify password\r\n    const isValidPassword = await bcrypt.compare(password, mockVendor.password);\r\n    if (!isValidPassword) {\r\n      return NextResponse.json(\r\n        { error: \"Invalid email or password\" },\r\n        { status: 401 }\r\n      );\r\n    }\r\n\r\n    // Create session\r\n    const sessionId = `session_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\r\n    \r\n    return NextResponse.json({\r\n      success: true,\r\n      sessionId,\r\n      vendorId: mockVendor.id,\r\n      vendorName: mockVendor.name,\r\n      email: mockVendor.email,\r\n    });\r\n\r\n  } catch (error) {\r\n    if (error instanceof z.ZodError) {\r\n      return NextResponse.json(\r\n        { error: \"Invalid input data\", details: error.errors },\r\n        { status: 400 }\r\n      );\r\n    }\r\n    \r\n    return NextResponse.json(\r\n      { error: \"Internal server error\" },\r\n      { status: 500 }\r\n    );\r\n  }\r\n}\r\n"],"names":[],"mappings":";;;;AAAA;AACA;AACA;;;;AAEA,0BAA0B;AAC1B,MAAM,cAAc,yKAAC,CAAC,MAAM,CAAC;IAC3B,OAAO,yKAAC,CAAC,MAAM,GAAG,KAAK;IACvB,UAAU,yKAAC,CAAC,MAAM,GAAG,GAAG,CAAC;AAC3B;AAEO,eAAe,KAAK,OAAoB;IAC7C,IAAI;QACF,MAAM,OAAO,MAAM,QAAQ,IAAI;QAC/B,MAAM,EAAE,KAAK,EAAE,QAAQ,EAAE,GAAG,YAAY,KAAK,CAAC;QAE9C,gDAAgD;QAChD,2CAA2C;QAC3C,MAAM,aAAa;YACjB,IAAI;YACJ,OAAO;YACP,UAAU;YACV,MAAM;QACR;QAEA,wBAAwB;QACxB,IAAI,UAAU,WAAW,KAAK,EAAE;YAC9B,OAAO,gJAAY,CAAC,IAAI,CACtB;gBAAE,OAAO;YAA4B,GACrC;gBAAE,QAAQ;YAAI;QAElB;QAEA,kBAAkB;QAClB,MAAM,kBAAkB,MAAM,8IAAM,CAAC,OAAO,CAAC,UAAU,WAAW,QAAQ;QAC1E,IAAI,CAAC,iBAAiB;YACpB,OAAO,gJAAY,CAAC,IAAI,CACtB;gBAAE,OAAO;YAA4B,GACrC;gBAAE,QAAQ;YAAI;QAElB;QAEA,iBAAiB;QACjB,MAAM,YAAY,CAAC,QAAQ,EAAE,KAAK,GAAG,GAAG,CAAC,EAAE,KAAK,MAAM,GAAG,QAAQ,CAAC,IAAI,MAAM,CAAC,GAAG,IAAI;QAEpF,OAAO,gJAAY,CAAC,IAAI,CAAC;YACvB,SAAS;YACT;YACA,UAAU,WAAW,EAAE;YACvB,YAAY,WAAW,IAAI;YAC3B,OAAO,WAAW,KAAK;QACzB;IAEF,EAAE,OAAO,OAAO;QACd,IAAI,iBAAiB,yKAAC,CAAC,QAAQ,EAAE;YAC/B,OAAO,gJAAY,CAAC,IAAI,CACtB;gBAAE,OAAO;gBAAsB,SAAS,MAAM,MAAM;YAAC,GACrD;gBAAE,QAAQ;YAAI;QAElB;QAEA,OAAO,gJAAY,CAAC,IAAI,CACtB;YAAE,OAAO;QAAwB,GACjC;YAAE,QAAQ;QAAI;IAElB;AACF","debugId":null}}]
}