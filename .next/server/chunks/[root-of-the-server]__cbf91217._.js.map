{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 3, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"","debugId":null}},
    {"offset": {"line": 61, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/aviji/OneDrive/Documents/marketplace/codeX/src/app/api/vendors/register/route.ts"],"sourcesContent":["import { NextResponse } from \"next/server\";\r\nimport bcrypt from \"bcryptjs\";\r\n\r\n// In-memory storage for demo - replace with database in production\r\nlet vendors: any[] = [];\r\n\r\nexport async function POST(request: Request) {\r\n  try {\r\n    const {\r\n      name,\r\n      email,\r\n      password,\r\n      businessName,\r\n      businessDescription,\r\n      phone,\r\n      location,\r\n      businessType,\r\n      serviceCategories\r\n    } = await request.json();\r\n\r\n    // Basic validation\r\n    if (!email || !password || !businessName) {\r\n      return NextResponse.json(\r\n        { error: \"Missing required fields\" },\r\n        { status: 400 }\r\n      );\r\n    }\r\n\r\n    // Check if email already exists\r\n    const existingVendor = vendors.find(v => v.email === email);\r\n    if (existingVendor) {\r\n      return NextResponse.json(\r\n        { error: \"Email already registered\" },\r\n        { status: 409 }\r\n      );\r\n    }\r\n\r\n    // Hash the password before storing\r\n    const hashedPassword = await bcrypt.hash(password, 10);\r\n\r\n    const newVendor = {\r\n      id: Date.now().toString(),\r\n      name,\r\n      email,\r\n      password: hashedPassword, // Store hashed password\r\n      businessName,\r\n      businessDescription,\r\n      phone,\r\n      location,\r\n      businessType,\r\n      serviceCategories,\r\n      verified: false,\r\n      createdAt: new Date().toISOString(),\r\n      updatedAt: new Date().toISOString()\r\n    };\r\n\r\n    vendors.push(newVendor);\r\n    \r\n    return NextResponse.json({\r\n      success: true,\r\n      vendor: {\r\n        id: newVendor.id,\r\n        name: newVendor.name,\r\n        email: newVendor.email,\r\n        businessName: newVendor.businessName,\r\n        verified: newVendor.verified\r\n      }\r\n    });\r\n  } catch (error) {\r\n    return NextResponse.json(\r\n      { error: \"Internal server error\" },\r\n      { status: 500 }\r\n    );\r\n  }\r\n}\r\n\r\n// GET endpoint to fetch all vendors (for admin purposes)\r\nexport async function GET() {\r\n  return NextResponse.json({ vendors });\r\n}\r\n"],"names":[],"mappings":";;;;;;AAAA;AACA;;;AAEA,mEAAmE;AACnE,IAAI,UAAiB,EAAE;AAEhB,eAAe,KAAK,OAAgB;IACzC,IAAI;QACF,MAAM,EACJ,IAAI,EACJ,KAAK,EACL,QAAQ,EACR,YAAY,EACZ,mBAAmB,EACnB,KAAK,EACL,QAAQ,EACR,YAAY,EACZ,iBAAiB,EAClB,GAAG,MAAM,QAAQ,IAAI;QAEtB,mBAAmB;QACnB,IAAI,CAAC,SAAS,CAAC,YAAY,CAAC,cAAc;YACxC,OAAO,gJAAY,CAAC,IAAI,CACtB;gBAAE,OAAO;YAA0B,GACnC;gBAAE,QAAQ;YAAI;QAElB;QAEA,gCAAgC;QAChC,MAAM,iBAAiB,QAAQ,IAAI,CAAC,CAAA,IAAK,EAAE,KAAK,KAAK;QACrD,IAAI,gBAAgB;YAClB,OAAO,gJAAY,CAAC,IAAI,CACtB;gBAAE,OAAO;YAA2B,GACpC;gBAAE,QAAQ;YAAI;QAElB;QAEA,mCAAmC;QACnC,MAAM,iBAAiB,MAAM,8IAAM,CAAC,IAAI,CAAC,UAAU;QAEnD,MAAM,YAAY;YAChB,IAAI,KAAK,GAAG,GAAG,QAAQ;YACvB;YACA;YACA,UAAU;YACV;YACA;YACA;YACA;YACA;YACA;YACA,UAAU;YACV,WAAW,IAAI,OAAO,WAAW;YACjC,WAAW,IAAI,OAAO,WAAW;QACnC;QAEA,QAAQ,IAAI,CAAC;QAEb,OAAO,gJAAY,CAAC,IAAI,CAAC;YACvB,SAAS;YACT,QAAQ;gBACN,IAAI,UAAU,EAAE;gBAChB,MAAM,UAAU,IAAI;gBACpB,OAAO,UAAU,KAAK;gBACtB,cAAc,UAAU,YAAY;gBACpC,UAAU,UAAU,QAAQ;YAC9B;QACF;IACF,EAAE,OAAO,OAAO;QACd,OAAO,gJAAY,CAAC,IAAI,CACtB;YAAE,OAAO;QAAwB,GACjC;YAAE,QAAQ;QAAI;IAElB;AACF;AAGO,eAAe;IACpB,OAAO,gJAAY,CAAC,IAAI,CAAC;QAAE;IAAQ;AACrC","debugId":null}}]
}